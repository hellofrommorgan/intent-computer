You are working on the intent-computer monorepo at /Users/morgan/Projects/intent-computer.

## Repo Structure

This is a pnpm workspace monorepo with 4 packages:
- packages/architecture/ — shared types, ports, domain models (@intent-computer/architecture)
- packages/plugin/ — opencode plugin with hooks, skills, adapters (@intent-computer/plugin)
- packages/mcp-server/ — standalone MCP server with 8 tools (@intent-computer/mcp-server)
- packages/heartbeat/ — autonomy engine, launchd-based (@intent-computer/heartbeat)

TypeScript throughout. Build with `pnpm run build`.

## Key Context: How Skills Execute

Skills in this system work by having an LLM follow markdown instructions while manipulating vault files:

1. **Injected skills**: SKILL.md loaded into system prompt → LLM follows instructions using file tools
2. **Forked skills**: Isolated LLM session created via client.session.create() → SKILL.md sent as context → LLM operates in isolation

The fork mechanism is in packages/plugin/src/skills/fork.ts. The key function is `forkSkill()` which:
- Takes skillName, skillInstructions (from SKILL.md), taskContext, vaultRoot, timeoutMs
- Creates an isolated LLM session via client.session.create()
- Sends the skill instructions + task context
- Returns { success, artifacts, error }

The skill SKILL.md files are in:
- packages/plugin/src/skill-sources/ (processing skills: reduce, reflect, revisit, verify, etc.)
- packages/plugin/src/plugin-skills/ (meta skills: health, setup, help, etc.)

The injector (packages/plugin/src/skills/injector.ts) loads and prepares SKILL.md content.
The function `loadSkillInstructions(skillName, vaultRoot)` returns the processed skill content.

## PHASE B: Close Loop 1 — Wire In-Session Dispatch Handlers

Currently, 4 of 6 execution dispatch handlers in packages/plugin/src/index.ts (lines 272-290) are STUBS that return advisory strings instead of actually doing work:

```typescript
connectOrphans: async () =>
  "No automatic orphan resolver configured. Invoke /reflect for targeted linking.",
triageObservations: async () =>
  "No automatic observation triage configured. Invoke /rethink to process observations.",
resolveTensions: async () =>
  "No automatic tension resolver configured. Invoke /rethink to resolve tensions.",
mineSessions: async () =>
  "No automatic session mining configured. Invoke /remember --mine-sessions.",
```

The TWO working handlers are:
- processQueue: calls runRalph() — fully implemented
- processInbox: calls runPipeline() — fully implemented

### TASK 1: Wire connectOrphans dispatch handler

Replace the stub with a real implementation that forks the /reflect skill.

In packages/plugin/src/index.ts, change the connectOrphans handler to:

```typescript
connectOrphans: async () => {
  const skillInstructions = await loadSkillInstructions("reflect", vaultRoot);
  if (!skillInstructions) return "Reflect skill not found — cannot connect orphans.";

  // Build task context: list orphan thoughts
  const orphanDir = join(vaultRoot, "thoughts");
  const allThoughts = readdirSync(orphanDir).filter(f => f.endsWith(".md"));
  const orphans: string[] = [];
  for (const file of allThoughts) {
    const name = file.replace(/\.md$/, "");
    // Check if any other file links to this one
    try {
      const result = await input.$`grep -rl "\\[\\[${name}\\]\\]" ${join(vaultRoot, "thoughts")} ${join(vaultRoot, "self")}`.text();
      if (!result.trim()) orphans.push(name);
    } catch {
      orphans.push(name); // grep returns non-zero when no matches
    }
  }

  if (orphans.length === 0) return "No orphan thoughts found.";

  const taskContext = [
    "# Orphan Connection Task",
    "",
    `Found ${orphans.length} orphan thoughts (no incoming wiki links).`,
    "Your job: find connections between these orphans and existing thoughts.",
    "For each orphan, either:",
    "1. Add wiki links FROM existing thoughts TO the orphan (update the existing thought)",
    "2. Add the orphan to a relevant map's topic list",
    "3. If truly unconnectable, note it for review",
    "",
    "Orphans to connect:",
    ...orphans.slice(0, 10).map(o => `- [[${o}]]`),
    orphans.length > 10 ? `\n...and ${orphans.length - 10} more` : "",
    "",
    `Vault root: ${vaultRoot}`,
    `Thoughts directory: ${join(vaultRoot, "thoughts")}`,
  ].join("\n");

  const result = await forkSkill(
    { skillName: "reflect", skillInstructions, taskContext, vaultRoot, timeoutMs: 300_000 },
    input.client, input.$,
  );

  return result.success
    ? `Connected orphans: ${result.artifacts?.length ?? 0} files modified`
    : `Orphan connection failed: ${result.error ?? "unknown error"}`;
},
```

You will need to add imports at the top of index.ts:
- `import { readdirSync } from "fs";` (if not already imported)
- `import { forkSkill } from "./skills/fork.js";` (if not already imported)
- `import { loadSkillInstructions } from "./skills/injector.js";` (if not already imported)

Check what's already imported before adding duplicates.

### TASK 2: Wire triageObservations dispatch handler

Replace the stub with a real implementation that forks the /rethink skill.

```typescript
triageObservations: async () => {
  const skillInstructions = await loadSkillInstructions("rethink", vaultRoot);
  if (!skillInstructions) return "Rethink skill not found — cannot triage observations.";

  const obsDir = join(vaultRoot, "ops", "observations");
  const obsFiles = existsSync(obsDir)
    ? readdirSync(obsDir).filter(f => f.endsWith(".md"))
    : [];

  if (obsFiles.length === 0) return "No pending observations to triage.";

  // Read first 10 observations for context
  const previews = obsFiles.slice(0, 10).map(f => {
    const content = readFileSync(join(obsDir, f), "utf-8");
    const firstLine = content.split("\n").find(l => l.trim() && !l.startsWith("---")) ?? f;
    return `- ${f}: ${firstLine.slice(0, 100)}`;
  });

  const taskContext = [
    "# Observation Triage Task",
    "",
    `Found ${obsFiles.length} pending observations in ops/observations/.`,
    "Your job: review each observation and decide:",
    "1. PROMOTE — if it reveals a pattern worth capturing as a thought, create the thought",
    "2. RESOLVE — if it's been addressed, mark status: resolved in frontmatter",
    "3. DEFER — if it needs more evidence, leave as-is",
    "",
    "Observations to triage:",
    ...previews,
    obsFiles.length > 10 ? `\n...and ${obsFiles.length - 10} more` : "",
    "",
    `Vault root: ${vaultRoot}`,
    `Observations directory: ${obsDir}`,
  ].join("\n");

  const result = await forkSkill(
    { skillName: "rethink", skillInstructions, taskContext, vaultRoot, timeoutMs: 300_000 },
    input.client, input.$,
  );

  return result.success
    ? `Triaged observations: ${result.artifacts?.length ?? 0} files modified`
    : `Observation triage failed: ${result.error ?? "unknown error"}`;
},
```

### TASK 3: Wire resolveTensions dispatch handler

Replace the stub with a real implementation that forks /rethink with tensions focus.

```typescript
resolveTensions: async () => {
  const skillInstructions = await loadSkillInstructions("rethink", vaultRoot);
  if (!skillInstructions) return "Rethink skill not found — cannot resolve tensions.";

  const tensionDir = join(vaultRoot, "ops", "tensions");
  const tensionFiles = existsSync(tensionDir)
    ? readdirSync(tensionDir).filter(f => f.endsWith(".md"))
    : [];

  if (tensionFiles.length === 0) return "No pending tensions to resolve.";

  const previews = tensionFiles.slice(0, 10).map(f => {
    const content = readFileSync(join(tensionDir, f), "utf-8");
    const firstLine = content.split("\n").find(l => l.trim() && !l.startsWith("---")) ?? f;
    return `- ${f}: ${firstLine.slice(0, 100)}`;
  });

  const taskContext = [
    "# Tension Resolution Task",
    "",
    `Found ${tensionFiles.length} pending tensions in ops/tensions/.`,
    "Tensions are contradictions between thoughts or between implementation and methodology.",
    "Your job: for each tension, decide:",
    "1. RESOLVE — if one side is clearly right, update the weaker thought and mark tension resolved",
    "2. SYNTHESIZE — if both sides have merit, create a new thought that reconciles them",
    "3. DISSOLVE — if the contradiction is apparent (different contexts), note why and mark dissolved",
    "",
    "Tensions to resolve:",
    ...previews,
    tensionFiles.length > 10 ? `\n...and ${tensionFiles.length - 10} more` : "",
    "",
    `Vault root: ${vaultRoot}`,
    `Tensions directory: ${tensionDir}`,
  ].join("\n");

  const result = await forkSkill(
    { skillName: "rethink", skillInstructions, taskContext, vaultRoot, timeoutMs: 300_000 },
    input.client, input.$,
  );

  return result.success
    ? `Resolved tensions: ${result.artifacts?.length ?? 0} files modified`
    : `Tension resolution failed: ${result.error ?? "unknown error"}`;
},
```

### TASK 4: Wire mineSessions dispatch handler

Replace the stub with a real implementation that forks /remember with session mining context.

```typescript
mineSessions: async () => {
  const skillInstructions = await loadSkillInstructions("remember", vaultRoot);
  if (!skillInstructions) return "Remember skill not found — cannot mine sessions.";

  const sessDir = join(vaultRoot, "ops", "sessions");
  const sessionFiles = existsSync(sessDir)
    ? readdirSync(sessDir).filter(f => f.endsWith(".json") || f.endsWith(".md")).sort().reverse()
    : [];

  if (sessionFiles.length === 0) return "No unprocessed sessions to mine.";

  // Take the 3 most recent sessions
  const recentSessions = sessionFiles.slice(0, 3);
  const sessionPreviews = recentSessions.map(f => {
    const content = readFileSync(join(sessDir, f), "utf-8");
    return `### ${f}\n${content.slice(0, 500)}...\n`;
  });

  const taskContext = [
    "# Session Mining Task",
    "",
    `Found ${sessionFiles.length} unprocessed session transcripts in ops/sessions/.`,
    "Your job: scan these transcripts for insights worth capturing as thoughts.",
    "Look for:",
    "1. Explicit insights the user stated but weren't captured",
    "2. Patterns across multiple sessions",
    "3. Decisions made that should be recorded",
    "4. Methodology learnings (how the system worked or didn't)",
    "",
    "For each insight found, create a thought in thoughts/ following the vault schema.",
    "After mining, you may move processed session files to ops/sessions/archive/.",
    "",
    `Processing ${recentSessions.length} most recent sessions:`,
    "",
    ...sessionPreviews,
    "",
    `Vault root: ${vaultRoot}`,
    `Sessions directory: ${sessDir}`,
  ].join("\n");

  const result = await forkSkill(
    { skillName: "remember", skillInstructions, taskContext, vaultRoot, timeoutMs: 300_000 },
    input.client, input.$,
  );

  return result.success
    ? `Mined sessions: ${result.artifacts?.length ?? 0} files modified`
    : `Session mining failed: ${result.error ?? "unknown error"}`;
},
```

### TASK 5: Update execution policy defaults

In packages/plugin/src/adapters/local-execution.ts, update the DEFAULT_POLICY (lines 43-57) to enable process_inbox since it now has a real handler:

Change:
```typescript
process_inbox: false,
```
To:
```typescript
process_inbox: true,
```

Keep all other autoExecute values as false — the other handlers are now wired but should remain opt-in until proven reliable. Users can enable them via ops/runtime-policy.json.

Also increase maxActionsPerCycle from 1 to 2:
```typescript
maxActionsPerCycle: 2,
```

This allows the system to process queue AND inbox in a single cycle if both have work.

## VERIFICATION

After completing all tasks:
1. Run `pnpm run build` — must complete with 0 errors
2. Verify no duplicate imports in index.ts
3. Verify all 6 dispatch handlers now have real implementations (grep for "No automatic" — should return 0 results in index.ts)
4. Verify the fork.ts and injector.ts imports are correct
5. Check that existsSync, readFileSync, readdirSync are imported from "fs" in index.ts

DO NOT modify any SKILL.md files, hooks, adapters (except local-execution.ts policy change), or test files.
